\section{Operational semantics}

\input{2-figure-operational-semantics}

We consider the denotational semantics to be primary in Datafun; as with
Datalog, any implementation technique is valid so long as it lines up with these
semantics.
%
To show such an implementation is possible, we present a simple call-by-value
structural operational semantics in \cref{figure-operational-semantics} and show
that all well-typed terms terminate.
%
In our operational semantics we:

\begin{enumerate}
\item Drop the distinction between discrete and monotone variables, writing both
  in lowercase $x,y,z$, and cease using a \isobgname\ background for
  non-monotone expressions.
\item Assume all equality tests and all semilattice operations ($\bot$, $\vee$,
  $\kw{for}$, and $\kw{fix}$) are subscripted with their type.
\item Add $\prim{iter}$ expressions, which occur as intermediate forms in the
  evaluation of $\kw{fix}$.
\end{enumerate}

\noindent
We use a small-step operational semantics with evaluation contexts
$E$~\citep{felleisen-hieb-1992} to enforce a call-by-value evaluation order; an
evaluation context $E$ is an expression with a hole in it, written $\emptyhole$,
such that whatever is in the hole is next in line to be evaluated (if it is not
a value already). To fill the hole in an evaluation context $E$ with the
expression $e$, we write $\fillhole{E}{e}$.

We define a relation $e \stepsto e'$ for expressions $e$ whose outermost
structure is immediately reducible; we extend this relation to all
expressions with the rule:

\[
\infer{e\stepsto e'}{\fillhole E e \stepsto \fillhole E{e'}}
\]

\noindent
In our rules for $e \stepsto e'$ where $e$ is an \prim{iter} expression we make
use of a decidable ordering test on values, $v \le u : \eqt A$, and a
corresponding equality test $v = u : \eqt A$. We define these using
inference rules, but they are easily seen to be decidable by induction on $\eqt
A$.

%\subsection{Computing fixed points by iteration}

Our implementation strategy for $\efix f$ is
% \todo{suggested by the proof of \cref{lemma-fixed-point}:}
straightforward: starting from $\bot$, iteratively apply $f$ until quiescence.
%
To model this process, we introduce the form
$\eiter{f}{e_1}{e_2}$, which evaluates two successive function iterations
$e_1,e_2$.
%
The fixed point expression$\efix f$, after evaluating $f$, steps to
$\eiter{f}{\bot}{f\<e}$, which kicks off the first two iterations.
%
Once these have reduced to values, $\eiter f {u_1}{u_2}$ tests $u_1 = u_2$ to
determine if a fixed point has been reached. If so, its value $u_1$ is returned;
otherwise we step to $\eiter{f}{u_2}{f\<u_2}$ to evaluate the next iteration,
and so on.

%% \subsection{A logical relation for termination}

%% \todo{logical relation for termination and adequacy}
